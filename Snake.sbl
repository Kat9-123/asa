#Standard.sbl*
#Symbols.sbl*
#IO.sbl
#Stack.sbl
#Func.sbl
#JumpIf.sbl

!Jump(_entry)

BACKGROUND -> '-'
APPLE -> 'a'
SNAKE_HEAD -> '@'
SNAKE_TAIL -> 'O'


snakePos -> 30

applePos -> 0x006F


tailStartPointer -> $3
tailEndPointer -> $3
TAIL_ARRAY -> $1 [0xFFFE] * 200 ; 20 * 10

EMPTY_TAIL_ELEMENT -> 0xFFFE
I_EMPTY_TAIL_ELEMENT -> 0x0002


applePosPtr -> $2
APPLE_POS_ARRAY -> $1 [0x0085, 0x0084, 0x0059, 0x005B, 0x0016, 0x004E, 0x0019, 0x0068, 0x0058, 0x006D, 0x0004, 0x001E, 0x00A2, 
					   0x000A, 0x0067, 0x0096, 0x006A, 0x001A, 0x001C, 0x007E, 0x0022, 0x0063, 0x0075, 0x0077, 0x004A, 0x0010, 
					   0x0007, 0x0030, 0x0093, 0x0072, 0x0086, 0x0001, 0x003E, 0x004F, 0x006E, 0x009C, 0x0038, 0x0050, 0x0000, 
					   0x00A3, 0x006F, 0x008E, 0x002F, 0x0055, 0x0078, 0x0054, 0x007A, 0x0097, 0x00B0, 0x0039, 0x0056, 0x0083, 
					   0x0094, 0x0090, 0x003A, 0x0018, 0x007F, 0x0011, 0x0003, 0x0066, 0x0070, 0x00C4, 0x002E, 0x00B9, 0x0031, 
					   0x006C, 0x0032, 0x00A6, 0x00C3, 0x008F, 0x005A, 0x0017, 0x0025, 0x007D, 0x00AE, 0x002A, 0x0045, 0x00A5, 
					   0x0026, 0x00AD, 0x00C2, 0x0034, 0x0051, 0x0092, 0x0046, 0x00B2, 0x000E, 0x00BF, 0x00C7, 0x00BA, 0x00B1, 
					   0x0079, 0x0012, 0x0002, 0x00BD, 0x0060, 0x000D, 0x000F, 0x00B8, 0x00BE, 0x00B6, 0x0076, 0x0073, 0x0006, 
					   0x0041, 0x008D, 0x004D, 0x000C, 0x0035, 0x0028, 0x009E, 0x0040, 0x009A, 0x0071, 0x0089, 0x00B5, 0x008B, 
					   0x0027, 0x008A, 0x00A0, 0x004C, 0x003C, 0x0065, 0x0021, 0x003B, 0x0047, 0x0069, 0x006B, 0x007B, 0x0064, 
					   0x00C6, 0x0098, 0x00A7, 0x0013, 0x0062, 0x00AA, 0x009F, 0x002C, 0x00A8, 0x0044, 0x003F, 0x0005, 0x0095, 
					   0x0015, 0x00B4, 0x00B3, 0x0024, 0x0023, 0x0081, 0x0049, 0x0037, 0x0014, 0x001B, 0x00A4, 0x003D, 0x0042, 
					   0x0043, 0x0087, 0x002D, 0x00BB, 0x0099, 0x00A9, 0x00C5, 0x0033, 0x00AB, 0x004B, 0x0074, 0x00AC, 0x005D, 
					   0x0053, 0x0008, 0x0052, 0x0036, 0x001D, 0x009B, 0x00BC, 0x0088, 0x0057, 0x00A1, 0x00C0, 0x000B, 0x0091, 
					   0x0029, 0x0080, 0x002B, 0x009D, 0x0020, 0x0061, 0x008C, 0x00C1, 0x00AF, 0x007C, 0x0082, 0x0009, 0x005F, 
					   0x005C, 0x00B7, 0x005E, 0x0048, 0x001F]

MAP_SIZE_X -> 20 \ MAP_SIZE_Y -> 10
MAP_SIZE_TOTAL -> 200

renderPos -> 0x0000


justGrown -> 0x0000



UP -> 'w'
DOWN -> 's'

LEFT -> 'a'
RIGHT -> 'd'



!Func::Def move

	; get input
	!Clear(input)
	!IO::GetChar(input)

	; check against supported keys
	!JumpIf::Eq(input,UP,_move_up)
	!JumpIf::Eq(input,DOWN,_move_down)
	!JumpIf::Eq(input,LEFT,_move_left)
	!JumpIf::Eq(input,RIGHT,_move_right)

	; no supported key pressed
	!Jump(_no_input)


	_move_up ->

		snakePos -= MAP_SIZE_X ; move up
			
		; finish input if snake isnt out of bounds
		!JumpIf::GrZero(snakePos,_fin_input)

		; snake is out of bounds. needs to be corrected
		!Add(snakePos,MAP_SIZE_TOTAL)

		!Jump(_fin_input)

	_move_down ->
		!Add(snakePos, MAP_SIZE_X) ; move down

		; finish input if snake isnt out of bounds
		!JumpIf::Geq(MAP_SIZE_TOTAL,snakePos,_fin_input)

		; snake is out of bounds. needs to be corrected
		snakePos -= MAP_SIZE_TOTAL
		!Jump(_fin_input)

	_move_left ->
		!Dec(snakePos) ; move left


		!Copy(snakePos,snakePosCopy)

		; Check if it came from a border cell
		!Inc(snakePosCopy)

		!Mod(snakePosCopy,MAP_SIZE_X)
		!JumpIfNotEq(snakePosCopy,ZERO,_fin_input)
		!Add(snakePos, MAP_SIZE_X)
		!Jump(_fin_input)

	_move_right ->
		!Inc(snakePos)


		!Copy(snakePos,snakePosCopy)
		!Mod(snakePosCopy,MAP_SIZE_X)
		!JumpIfNotEq(snakePosCopy,ZERO,_fin_input)
		snakePos -= MAP_SIZE_X
		!Jump(_fin_input)


	input -> 0x0000
	snakePosCopy -> 0x0000

	_fin_input ->

		!Func::Return(ZERO)
	_no_input ->
		!Func::Return(N_ONE)




!Func::Def apple_eat_check

	; jump if not eating
	!JumpIf::NotEq(snakePos,applePos,_no_apple)

	; Snake on apple
	; Set new apple pos
	_new_apple_pos_routine ->
		applePosPtr -= APPLE_POS_ARRAY
		!Mod(applePosPtr,MAP_SIZE_TOTAL)
		!Add(applePosPtr,APPLE_POS_ARRAY)

		!Clear(applePos)
		!Clear(iApplePos)
		!Clear(newApplePos)

		!Copy(applePosPtr, applePtrCopy)
		!Inc(applePosPtr)

		applePtrCopy -a>
		iApplePos -= 0x0000,

		newApplePos -= iApplePos
		; check if apple spawns in player head
		!JumpIf::Eq(newApplePos,snakePos,_new_apple_pos_routine)
		; check if apple spawns in tail
		!JumpIfInTailArray(newApplePos,_new_apple_pos_routine)

		; apple can safely spawn
		applePos -= iApplePos

		



		

		; Add to snake
		!Inc(tailEndPointer)




		!CopyValToDereferencedPtr(snakePos,tailEndPointer)

		!Copy(ONE,justGrown)

	; snake not on apple
	_no_apple ->
		!Func::Return(VOID)


	iApplePos -> 0x0000
	newApplePos -> 0x0000



!Func::Def move_tail

	; Make sure the array pointers stay in the bounds of the circular buffer
	tailStartPointer -= TAIL_ARRAY
	tailEndPointer -= TAIL_ARRAY
	!Mod(tailStartPointer,MAP_SIZE_TOTAL)
	!Mod(tailEndPointer,MAP_SIZE_TOTAL)

	!Add(tailStartPointer, TAIL_ARRAY)
	!Add(tailEndPointer,TAIL_ARRAY)

	; Clear old
	; If justgrown is true (1) return. if false (0) complete procedure

	!JumpIf::Eq(justGrown,FALSE,_move_tail)
		justGrown -= Z, _move_tail
		!Clear(justGrown)
		!Func::Return(VOID)

	_move_tail ->


		!CopyValToDereferencedPtr(EMPTY_TAIL_ELEMENT,tailStartPointer)



		!Inc(tailEndPointer)

		

		!CopyValToDereferencedPtr(snakePos,tailEndPointer)


		
		!Inc(tailStartPointer)

		!Func::Return(VOID)









!Func::Def draw
	!Clear(renderPos) \ !Clear(modTest)
	

	_draw_loop ->
		; Check if snake head
		!JumpIfNotEq(renderPos,snakePos,_not_snake_head)
		!IO::PrintChar(SNAKE_HEAD)
		!Jump(_char_finished)

		_not_snake_head ->
		; Check if apple
		!JumpIfNotEq(renderPos,applePos,_not_apple)
		!IO::PrintChar(APPLE)
		!Jump(_char_finished)

		_not_apple ->
		; Check if tail


		!JumpIfInTailArray(renderPos,_is_tail)
			!Jump(_not_tail)

        ; is in array
		_is_tail ->
			!IO::PrintChar(SNAKE_TAIL)
			!Jump(_char_finished)



		_not_tail ->

		; if nothing else
		!IO::PrintChar(BACKGROUND)

		_char_finished ->
			!Inc(renderPos)
			!Copy(renderPos,modTest)
			!Mod(modTest,MAP_SIZE_X)

			; exit condition
			!JumpIfEq(renderPos,MAP_SIZE_TOTAL,_draw_fin)

			!JumpIfEq(renderPos,ZERO,_draw_loop)
			!JumpIfNotEq(modTest,ZERO,_draw_loop)
			
			
			
			!IO::PrintChar(NEWLINE)



			!Jump(_draw_loop)
		
		



	;;;
	modTest -> 0
	tailVal -> 0x0000
	invertedTailVal -> 0x0000



	_draw_fin ->
		!Func::Return(VOID)
	
	;	








!Func::Def loss_check
	!JumpIfInTailArray(snakePos,_lose)

		!Func::Return(VOID)

	_lose ->
		!Halt()

@JumpIfInTailArray(val,_address)
{
	!Copy(tailStartPointer,drawTailStartPtrCopy)

	_tail_loop ->
		; Make sure it stays within bounds of circular buffer
		drawTailStartPtrCopy -= TAIL_ARRAY
		!Mod(drawTailStartPtrCopy,MAP_SIZE_TOTAL)
		!Add(drawTailStartPtrCopy, TAIL_ARRAY)

		;
        !Clear(invertedTailVal)
        !Clear(tailVal)

        drawTailStartPtrCopy -a> ; (pointer)
        invertedTailVal -= 0x0000, ;=-
        tailVal -= invertedTailVal

        ; tailVal = EMPTY_TAIL_ELEMENT, not in tail array
		!JumpIf::Eq(tailVal,EMPTY_TAIL_ELEMENT,_fin)


        !Inc(drawTailStartPtrCopy)


        ; jump if is in array
        !JumpIfEq(val,tailVal,_address)
		; else loop
		!Jump(_tail_loop)


    tailVal -> 0x0000
	invertedTailVal -> 0x0000

	_fin ->

}

end

@CopyValToDereferencedPtr(val,ptr)
{
	!Copy(ptr,clearA)
	!Copy(ptr,clearB)
	!Copy(ptr,writeB)
	
	

	; clear
	clearA ->
	0x0000 0x0000,
	clearB --1> ; FIX NEGATIVES ----------------



	; write
	!Clear(temp)
	temp -= val
	writeB -b>
	0x0000 -= temp,


	!Jump(_fin)


	temp -> 0x0000



	_fin ->
}
end





_entry ->
	!Stack::Init() ; function stack
	_gameLoop ->
		
		
		!IO::PrintChar(NEWLINE) \ !IO::PrintChar(NEWLINE)
		!Func::Call(loss_check)
		!Func::Call(apple_eat_check)
		!Func::Call(move_tail)
		!Func::Call(draw)
		

		; input loop. wait untill supported key is pressed.
		_input_loop ->
			!Func::Call(move)
			!JumpIf::Eq(Func::returnVal, ZERO, _gameLoop)
			!Jump(_input_loop)


	;_fin ->
	;!Halt()


