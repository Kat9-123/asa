; Zero comp
@JumpIf::GrZero val? .address?
{

    val? -= ZERO  .not_greater
    !J .address?

    .not_greater ->
}


@JumpIf::GeqZero val? .address? {
    !JumpIf::Eq val? SMALLEST_NEGATIVE .fin

    !Debug val?
    !Debug SMALLEST_NEGATIVE
    !Clear i_val
    i_val -= val?
    i_val -= ZERO .address?
    !J .fin

    i_val -> 0
    .fin ->
}


@JumpIf::LeZero num? .address?
{

    ; If this doesnt branch  it isnt <= 0
    num? -= ZERO  .leq

    !J .fin

    ; It is leq
    .leq ->
    !JumpIf::EqZero num? .fin

    ; its < 0 !
    !Jump .address?





    .fin ->
}



@JumpIf::EqZero num? .address?
{
    !JumpIf::Eq num? SMALLEST_NEGATIVE .notZero

    !Clear A
    ; jump if x is great than or equal to zero

    A -= num? .greaterThanOrEqual

    !Jump .notZero



    .greaterThanOrEqual ->
    !Clear B
    ; jump if x is smaller than or equal to zero
    B -= A .address?   ; If x is leq and geq zero it must be zero.


    !Jump .notZero


    A -> 0xA000
    B -> 0xB000


    .notZero ->
    
}



; N comp

@JumpIf::Le a? b? .address?
{
    !JumpIf::Geq a? b? .notLess
    !Jump .address?

    .notLess ->
}



@JumpIf::Geq a? b? .address?
{

    !Copy b? temp

    temp -= a? .address?


    !Jump .less

    temp -> 0x0000
    .less ->
}



@JumpIf::Eq a? b? .address?
{
    !Clear i_a
    !Clear i_b
    i_a -= a?
    i_b -= b?


    i_a -= i_b .first_check_success
    !J .fin

    .first_check_success ->
    i_b -= i_a .address?
    !J .fin

    i_a -> 0
    i_b -> 0



    .fin ->
}


@JumpIf::NotEq a? b? .address?
{
    !JumpIf::Eq a? b? .equal
    !Jump .address?

    .equal ->
}
