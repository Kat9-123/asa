

; https://gist.github.com/howerj/4e0741370bd22b3181443bf3e0ba6697
**
    This routine is expensive, but necessary.
**
@JumpIf::Le a? b? .address? {

**
	const int a0 = leq0(a);
	const int b0 = leq0(b);
	if (a0 && !b0)
		return 1;
	if (!a0 && b0)
		return 0;
	if (a0 && b0) {
		if (!leq0(a + 1) && leq0(b + 1))
			return 0;
	}
	const int l = leq0((uint16_t)(a - b));
	return l ? leq0((uint16_t)((a + 1) - b)) : 0;
**

    !Cpy a? a_plus_one
    !Cpy b? b_plus_one
    !Cpy a? l
    a_plus_one -= N_ONE
    b_plus_one -= N_ONE

    a? -= ZERO .a_not_b
    !J .not_a_b

.a_not_b -> ; a<=0 && !b<=0
    b? -= ZERO .a_b
    !J .address?

.not_a_b ->   ; !a<=0 && b<=0
    b? -= ZERO .fin
    !J .a_b

.a_b ->   ; a<=0 && b<=0
    a? -= ZERO .S
    !J .final
.S ->
    b? -= ZERO .N
    !J .final
.N ->


    a_plus_one -= ZERO .final
    b_plus_one -= ZERO .fin


.final ->
    l -= b? .TN
    !J .fin


.TN ->

    a_plus_one -= b? .address?

    !J .fin

a_plus_one -> 0
b_plus_one -> 0
l -> 0

.fin ->
}



@JumpIf::Ge a? b? .address? {
    !JumpIf::Le b? a? .address?
}



@JumpIf::Geq a? b? .address? {
    ; !Flip (!JumpIf::Le a? b? ) .address? ; investigate why this doesnt work
    !JumpIf::Le a? b? .fin
    !J .address?

    .fin ->
}

@JumpIf::Leq A? B? .address? {
    !JumpIf::Geq B? A? .address?
}


@JumpIf::Neq A? B? .address?{
    !JumpIf::Eq A? B? .fin
    !J .address?

    .fin ->
}
@JumpIf::Eq a? b? .address? {
    !JumpIf::Le a? b? .fin
    !JumpIf::Ge a? b? .fin
    !J .address?

    .fin ->
}


; Can be optimised
@JumpIf::LeZero a? .address? {
    !JumpIf::Le a? ZERO .address?
}

@JumpIf::GeqZero a? .address? {
    !JumpIf::Le a? ZERO .fin
    !J .address?
    .fin ->
}



**

; Zero comp
@JumpIf::GrZero val? .address?
{

    val? -= ZERO  .not_greater
    !J .address?

    .not_greater ->
}


@JumpIf::GeqZero val? .address? {
    !JumpIf::Eq val? SMALLEST_NEGATIVE .fin

    !Clear i_val
    i_val -= val?
    i_val -= ZERO .address?
    !J .fin

    i_val -> 0
    .fin ->
}


@JumpIf::LeZero num? .address?
{

    ; If this doesnt branch  it isnt <= 0
    num? -= ZERO  .leq

    !J .fin

    ; It is leq
    .leq ->
    !JumpIf::EqZero num? .fin

    ; its < 0 !
    !Jump .address?





    .fin ->
}



@JumpIf::EqZero num? .address?
{
    !Debug num?

    !JumpIf::Eq num? SMALLEST_NEGATIVE .notZero
    !Clear A
    ; jump if x is great than or equal to zero

    A -= num? .greaterThanOrEqual

    !Jump .notZero



    .greaterThanOrEqual ->
    !Clear B
    ; jump if x is smaller than or equal to zero
    B -= A .address?   ; If x is leq and geq zero it must be zero.


    !Jump .notZero


    A -> 0xA000
    B -> 0xB000


    .notZero ->
    
}






@JumpIf::Geq a? b? .address?
{

    !Copy b? temp

    temp -= a? .address?


    !Jump .less

    temp -> 0x0000
    .less ->
}


@JumpIf::EqSNEG a? .address?
{
    !Cpy a? i_a1
    !Cpy SNEG i_b
    !Cpy a? i_a2

    !Inc i_b
    !Inc i_a1
    !Inc i_a2


    i_a1 -= i_b .first_check_success
    !J .fin

    .first_check_success ->

    
    i_b -= i_a2 .address?
    !J .fin

    i_a1 -> 0
    i_b -> 0

    i_a2 -> 0
    .fin ->
}

@JumpIf::Eq a? b? .address?
{
    !JumpIf::EqSNEG a? .sneg_test

    .normal ->
    !Cpy a? i_a
    !Cpy b? i_b


    i_a -= b? .first_check_success
    !J .fin

.first_check_success ->

    
    i_b -= a? .address?
    !J .fin

.sneg_test ->
    !JumpIf::EqSNEG b? .address?
    !J .normal

    i_a -> 0
    i_b -> 0

.fin ->
}


@JumpIf::NotEq a? b? .address?
{
    !JumpIf::Eq a? b? .equal
    !Jump .address?

    .equal ->
}
**