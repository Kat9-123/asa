Z -= Z .main
#Sublib
#Sublib/Stack
#Sublib/Control
**
LOW
....
Return address <- fp
arg1
arg2
arg3
Return value    <- sp
....
Return address
arg1
.. etc
HIGH
**
**
a -> &2 1
b -> &2 2
Z -> 0

@TestMac s_a? {
    s_a?
}

.main ->
    a b
**

function_stack -> !Stack::Create 128


@Func name? b_args? s_body? [

    name? ->
    {
        b_args?
        s_body?
        !Func::Return
    }
]



@Func::Call name? s_args? {
    !Cpy ARGS_END arg_idx
 ;   !IO::PrintLit "RET "
    ;!ASM::Breakpoint
    !Stack::Push function_stack _return_address
    .arg_loop ->
        !Clr n_arg
        !Clr cur_arg
        !Dec arg_idx

        !JumpIf::Le arg_idx ARG_BASE name?

        n_arg -= (arg_idx -> 0)
        cur_arg -= n_arg

        !DerefAndCopy cur_arg derefed_cur_arg
        
       ; !ASM::Debug cur_arg
        ;!IO::PrintLn cur_arg
     ;   !ASM::Debug arg_idx
    ;    !ASM::Debug ARGS_END
       ; !IO::PrintLit "ARG "
        !Stack::Push function_stack derefed_cur_arg
        !J .arg_loop
     ;   !ASM::Debug arg_idx
       ; !ASM::Breakpoint


   ; !IO::PrintLnLit "JP"

    n_arg -> 0
    derefed_cur_arg -> 0
    cur_arg -> 0
    0xABCD
    ARG_BASE -> &s_args?
    ARGS_END -> $0

    _return_address -> $1
}


@Func::Return {
    !Stack::Pop function_stack return_addr
    W -= W (return_addr -> 0x0000)
}


@Arg name? [
    !Stack::Pop function_stack name?
    !J $2
    name? -> 0
]


!Func FUNtest (
    !Arg a
    !Arg c
    ) {





   ; !ASM::Debug c
    !IO::PrintLn a

    !IfElse c {
        !Func::Call FUNtest {d FALSE }
    } **Else** {
        !IO::PrintLnLit "FIN"
    }

    !IO::PrintLn a

}

b -> &"Test"
a -> &"string"
d -> &"APPOL"
.main ->

    !Func::Call FUNtest { a TRUE }

    !IO::PrintLnLit "END"
    !Halt

